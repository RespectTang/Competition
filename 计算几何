/***********************************************************************************************************************/
判断两直线是否相交
参考资料：https://www.cnblogs.com/wuwangchuxin0924/p/6218494.html
快速排斥和跨立实验
/***********************************************************************************************************************/
/*
1469.德莱联盟 (10分) NYOJ 1016
C时间限制：3000 毫秒 |  C内存限制：3000 Kb
题目内容：
欢迎来到德莱联盟。。。。
德莱文。。。
德莱文在逃跑，卡兹克在追。。。。
我们知道德莱文的起点和终点坐标，我们也知道卡兹克的起点和 终点坐标，
问：卡兹克有可能和德莱文相遇吗？，并且保证他们走的都是直线。
http://acm.nyist.edu.cn/JudgeOnline/problem.php?pid=1016
输入描述
几组数据，一个整数T表示T组数据
每组数据 8个实数，分别表示德莱文的起点和终点坐标，以及卡兹克的起点和终点坐标
输出描述
如果可能 输出 Interseetion,否则输出 Not Interseetion
输入样例
2
-19.74 7.14 22.23 -27.45 -38.79 -5.08 47.51 34.01
-8.61 9.91 -32.47 6.47 -3.81 -16.1 7.82 -6.37
输出样例
Interseetion
Not Interseetion
*/
#include<stdio.h>
#include<algorithm>
#include<math.h>
using namespace std;
struct node{
	double x,y;
};
struct st{
	node a,b;
}data[2];

int judge(int i,int j)
{
	if(min(data[i].a.x,data[i].b.x)>max(data[j].a.x,data[j].b.x))
	    return 0;
	if(min(data[i].a.y,data[i].b.y)>max(data[j].a.y,data[j].b.y))
	    return 0;
	if(min(data[j].a.x,data[j].b.x)>max(data[i].a.x,data[i].b.x))
	    return 0;
	if(min(data[j].a.y,data[j].b.y)>max(data[i].a.y,data[i].b.y))
	    return 0;
	double k=(data[i].a.x-data[j].a.x)*(data[j].b.y-data[j].a.y)-(data[i].a.y-data[j].a.y)*(data[j].b.x-data[j].a.x);
	double l=(data[i].b.x-data[j].a.x)*(data[j].b.y-data[j].a.y)-(data[i].b.y-data[j].a.y)*(data[j].b.x-data[j].a.x);
	double m=(data[j].a.x-data[i].a.x)*(data[i].b.y-data[i].a.y)-(data[j].a.y-data[i].a.y)*(data[i].b.x-data[i].a.x);
	double n=(data[j].b.x-data[i].a.x)*(data[i].b.y-data[i].a.y)-(data[j].b.y-data[i].a.y)*(data[i].b.x-data[i].a.x);
	return k*l<=0&&m*n<=0;
}

int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		for(int i=0;i<2;i++)
			scanf("%lf%lf%lf%lf",&data[i].a.x,&data[i].a.y,&data[i].b.x,&data[i].b.y);
		if(judge(0,1))
			printf("Interseetion\n");
		else
			printf("Not Interseetion\n");
	}
	return 0;
}
/***********************************************************************************************************************/
多边形重心问题
参考资料：https://www.cnblogs.com/jbelial/archive/2011/08/08/2131165.html
累加和求重心
/***********************************************************************************************************************/
/*
1470.多边形重心问题 (10分) 
C时间限制：3000 毫秒 |  C内存限制：3000 Kb
题目内容：
 在某个多边形上，取n个点，这n个点顺序给出，按照给出顺序将相邻的点用直线连接，
（第一个和最后一个连接），所有线段不和其他线段相交，但是可以重合，可得到一个
多边形或一条线段或一个多边形和一个线段的连接后的图形； 
如果是一条线段,我们定义面积为0，重心坐标为（0,0）.现在求给出的点集组成的图形
的面积和重心横纵坐标的和；
输入描述
第一行有一个整数0<n<11,表示有n组数据；
每组数据第一行有一个整数m<10000,表示有这个多边形有m个顶点；
输出描述
输出每个多边形的面积、重心横纵坐标的和，小数点后保留三位；
输入样例
3
3
0 1
0 2
0 3
3
1 1
0 0
0 1
4
1 1
0 0
0 0.5
0 1
输出样例
0.000 0.000
0.500 1.000
0.500 1.000
*/ 
#include<iostream>
#include<cstdio>
#include<cmath>
#include<stdlib.h>
using namespace std;
struct node{
	double x,y;
};
double Area(node p0,node p1,node p2)
{
    double area=0 ;
    area=p0.x*p1.y+p1.x*p2.y+p2.x*p0.y-p1.x*p0.y-p2.x*p1.y-p0.x*p2.y;
    return area/2 ;  // 另外在求解的过程中，不需要考虑点的输入顺序是顺时针还是逆时针，相除后就抵消了。
}
int main()
{
	node p0,p1,p2;
	double sumx,sumy,sumarea,area;
	int T,n;
	scanf("%d",&T);
	while(T--)
	{
		sumx=sumy=sumarea=0;
		scanf("%d",&n);
		scanf("%lf%lf",&p0.x,&p0.y);
		scanf("%lf%lf",&p1.x,&p1.y);
		for(int i=2;i<n;i++)
		{
			scanf("%lf%lf",&p2.x,&p2.y);
			area=Area(p0,p1,p2);
			sumarea+=area;
			sumx+=(p0.x+p1.x+p2.x)*area;
			sumy+=(p0.y+p1.y+p2.y)*area;
			p1=p2;
		}
		if(sumarea==0)
			printf("%.3lf 0.000\n",abs(sumarea));
		else
			printf("%.3lf %.3lf\n",abs(sumarea),sumx/sumarea/3+sumy/sumarea/3);
	}
	return 0;
}
/***********************************************************************************************************************/
凸包问题
参考资料：
https://blog.csdn.net/u014688145/article/details/72200018
https://blog.csdn.net/miku531/article/details/81222146
https://blog.csdn.net/acm_code/article/details/38370049
/***********************************************************************************************************************/
/*
1473.计算几何-奶牛 (10分)
C时间限制：3000 毫秒 |  C内存限制：3000 Kb
题目内容：
在一片草地上长着一些分散的树，现在要在这片草地上建造一个牧场，方法是将草地上的树看成平面
上的点，在这些点找到可以围成的最大凸多边形，用绳子将凸多边形圈起来即可，已知牧场上每50平方
米可以养一头奶牛，则所围成的牧场最多可以养多少头奶牛？
输入描述
第一行输入包含一个整数n（1≤n≤10000），包含在可用土地上生长的树的数量。
接下来的n行包含每个树的整数坐标，以两个整数x和y分隔一个空格（其中-1000≤x，y≤1000）。
整数坐标精确地与以米为单位的距离相关（例如，坐标（10; 11）和（11; 11）之间的距离是一米）。
输出描述
您将输出一个整数值，即可以使用可用树构建的最大牧场上可以存活的奶牛数量。
输入样例
4
0 0
0 101
75 0
75 101
输出样例
151
*/

#include<iostream>
#include<cmath>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cstdio>
using namespace std;
#define MAXN 1010
struct node{
	int x,y;
}A[MAXN],result[MAXN];

int dist(node a,node b)//距离的平方 
{
	return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);
}

int cp(node p1,node p2,node p3)//叉乘 
{
	return (p3.x-p1.x)*(p2.y-p1.y)-(p3.y-p1.y)*(p2.x-p1.x);
}

bool cmp(node a,node b)
{
	int ans=cp(A[0],a,b);
	if(ans==0)//ab共线 
		return dist(A[0],a)-dist(A[0],b)<=0;//判断A[0]a>A[0]b 
	else
		return ans>0; 
 } 

int main()
{
	int n;
	while(scanf("%d",&n)!=EOF)
	{
		int pos=0;
		for(int i=0;i<n;i++)
		{
			scanf("%d%d",&A[i].x,&A[i].y);
			if(A[pos].y>=A[i].y)
			{
				if(A[pos].y==A[i].y){
						if(A[pos].x>A[i].x)pos=i;
					}
					else pos=i;
			}	
		}//找到最上面的那个点pos；pos肯定在凸包上；
		if(n<3)
		{
			printf("0ok\n");
			continue;
		}
		node temp;
		int top=1;
		temp=A[0];A[0]=A[pos];A[pos]=temp;
		sort(A+1,A+n,cmp);
		result[0]=A[0];
		result[1]=A[1];
		for(int i=2;i<n;i++)
		{
			while(cp(result[top-1],result[top],A[i])<0) top--;//top从1开始 如果 1,3向量在1,2的顺时针方向删去1,2直到下一个向量在逆时针 
			result[++top]=A[i];//存入逆时针 
		}
		double s=0;
		for(int i=0;i<=top;i++)
		{
			double area=(result[(i+1)%(top+1)].x*result[i].y-result[(i+1)%(top+1)].y*result[i].x)/2.0;//分成top+1个三角形求面积 
			s+=area;	
		}
		printf("%d\n",(int)(s/50.0));	
	}
	return 0;
 } 
/***********************************************************************************************************************/
/*
 1474.计算几何-墙 (10分) 
C时间限制：3000 毫秒 |  C内存限制：3000 Kb
题目内容：
曾几何时，有一位贪婪的国王命令他的首席建筑师在国王城堡周围建造一堵墙。国王太贪心了，
他不会听他的建筑师的建议，建造一个漂亮的、 拥有完美造型和漂亮高塔的墙。
相反，他下令在整个城堡周围修建的隔离墙要求使用最少量的石头和劳动力，但又要求隔离墙要距离城堡一定间隔。
如果国王发现建筑师，在建造这堵墙时，除了满足这些必要要求外，使用了多余的资源， 建筑师将失去他的脑袋。
而且，国王要求建筑师立即列出建立隔离墙所需的确切资源数量。 
你的任务是通过编写一个程序救救可怜的建筑师， 帮他找到可以建造的最小可能长度的墙，并且这堵墙可以满足国王的要求 。 
事实上，国王的城堡有多边形的形状，并且位于平坦的地面上。建筑师已经建立了笛卡尔坐标系并精确测量了所有城堡顶点的坐标，以米为单位。
Hint
结果四舍五入就可以了
输入描述
输入文件的第一行包含两个整数N和L.被空格隔开。 N（3 <= N <= 1000）是顶点数，L（1 <= L <= 1000）是国王要求的允许墙壁靠近城堡的最小的距离。
接下来的N行以顺时针顺序描述城堡顶点的坐标。每行包含由空格分隔的两个整数Xi和Yi（-10000 <= Xi，Yi <= 10000）表示第i个顶点的坐标。
所有顶点都不重合，城堡的所有边也不会重合。
输出描述
输出一个数字，表示可以围绕城堡建造的墙壁的最小可能长度。 
满足King的要求。您必须显示整数米，对国王来说，因为浮动数字尚未发明。
但是，您必须以这样的方式对结果进行舍入，以确保结果准确，因为国王会不能容忍估计中的较大误差。
输入样例
9 100
200 400
300 400
300 300
400 300
400 400
500 400
500 200
350 200
200 200
输出样例
1628
*/
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<cstdlib>
using namespace std;
#define MAXN 10010
int m,top;
struct node{
	int x,y;
}p[MAXN],s[MAXN];

double dist(node a,node b)//距离
{
	return sqrt((a.x-b.x)*(a.x-b.x)*1.0+(a.y-b.y)*(a.y-b.y)*1.0);
}

int cp(node p1,node p2,node p3)//叉乘 
{
	return (p1.x-p2.x)*(p3.y-p2.y)-(p3.x-p2.x)*(p1.y-p2.y);
}

bool cmp(node a,node b)
{
	int k=cp(a,p[0],b);
	if(k>0||(k==0&&dist(a,p[0])<dist(b,p[0])))
		return true;
	else return false;
} 
void graham()
{
	node t;
	int k=0;
	for(int i=1;i<m;i++)
		if(p[i].y<p[k].y||(p[i].y==p[k].y&&p[i].x<p[k].x))
			k=i;
	t=p[k];p[k]=p[0];p[0]=t;
	sort(p+1,p+m,cmp);
	s[0]=p[0];
	s[1]=p[1];
	top=1;
	for(int i=2;i<m;i++)
	{
		while(top>=1&&cp(s[top-1],s[top],p[i])>=0)
			top--;
		s[++top]=p[i];//注意这里一定是++top，或者先对top进行++再运算 
	}
}

int main()
{
	int n;
	double sum;
	while(scanf("%d%d",&m,&n)!=EOF)
	{
		for(int i=0;i<m;i++)
			scanf("%d%d",&p[i].x,&p[i].y);
		graham();
		sum=dist(s[0],s[top])+2*3.1415926*n;
		for(int i=1;i<=top;i++)
			sum+=dist(s[i-1],s[i]);
		printf("%.0lf\n",sum); 
	}
	return 0;
}
/***********************************************************************************************************************/
/***********************************************************************************************************************/
/***********************************************************************************************************************/
/***********************************************************************************************************************/
/***********************************************************************************************************************/
/***********************************************************************************************************************/
/***********************************************************************************************************************/
/***********************************************************************************************************************/

