/***********************************************************************************************************************/
判断两直线是否相交
参考资料：https://www.cnblogs.com/wuwangchuxin0924/p/6218494.html
快速排斥和跨立实验
/***********************************************************************************************************************/
/*
1469.德莱联盟 (10分) NYOJ 1016
C时间限制：3000 毫秒 |  C内存限制：3000 Kb
题目内容：
欢迎来到德莱联盟。。。。
德莱文。。。
德莱文在逃跑，卡兹克在追。。。。
我们知道德莱文的起点和终点坐标，我们也知道卡兹克的起点和 终点坐标，
问：卡兹克有可能和德莱文相遇吗？，并且保证他们走的都是直线。
http://acm.nyist.edu.cn/JudgeOnline/problem.php?pid=1016
输入描述
几组数据，一个整数T表示T组数据
每组数据 8个实数，分别表示德莱文的起点和终点坐标，以及卡兹克的起点和终点坐标
输出描述
如果可能 输出 Interseetion,否则输出 Not Interseetion
输入样例
2
-19.74 7.14 22.23 -27.45 -38.79 -5.08 47.51 34.01
-8.61 9.91 -32.47 6.47 -3.81 -16.1 7.82 -6.37
输出样例
Interseetion
Not Interseetion
*/
#include<stdio.h>
#include<algorithm>
#include<math.h>
using namespace std;
struct node{
	double x,y;
};
struct st{
	node a,b;
}data[2];

int judge(int i,int j)
{
	if(min(data[i].a.x,data[i].b.x)>max(data[j].a.x,data[j].b.x))
	    return 0;
	if(min(data[i].a.y,data[i].b.y)>max(data[j].a.y,data[j].b.y))
	    return 0;
	if(min(data[j].a.x,data[j].b.x)>max(data[i].a.x,data[i].b.x))
	    return 0;
	if(min(data[j].a.y,data[j].b.y)>max(data[i].a.y,data[i].b.y))
	    return 0;
	double k=(data[i].a.x-data[j].a.x)*(data[j].b.y-data[j].a.y)-(data[i].a.y-data[j].a.y)*(data[j].b.x-data[j].a.x);
	double l=(data[i].b.x-data[j].a.x)*(data[j].b.y-data[j].a.y)-(data[i].b.y-data[j].a.y)*(data[j].b.x-data[j].a.x);
	double m=(data[j].a.x-data[i].a.x)*(data[i].b.y-data[i].a.y)-(data[j].a.y-data[i].a.y)*(data[i].b.x-data[i].a.x);
	double n=(data[j].b.x-data[i].a.x)*(data[i].b.y-data[i].a.y)-(data[j].b.y-data[i].a.y)*(data[i].b.x-data[i].a.x);
	return k*l<=0&&m*n<=0;
}

int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		for(int i=0;i<2;i++)
			scanf("%lf%lf%lf%lf",&data[i].a.x,&data[i].a.y,&data[i].b.x,&data[i].b.y);
		if(judge(0,1))
			printf("Interseetion\n");
		else
			printf("Not Interseetion\n");
	}
	return 0;
}
/***********************************************************************************************************************/
多边形重心问题
参考资料：https://www.cnblogs.com/jbelial/archive/2011/08/08/2131165.html
累加和求重心
/***********************************************************************************************************************/
/*
1470.多边形重心问题 (10分) 
C时间限制：3000 毫秒 |  C内存限制：3000 Kb
题目内容：
 在某个多边形上，取n个点，这n个点顺序给出，按照给出顺序将相邻的点用直线连接，
（第一个和最后一个连接），所有线段不和其他线段相交，但是可以重合，可得到一个
多边形或一条线段或一个多边形和一个线段的连接后的图形； 
如果是一条线段,我们定义面积为0，重心坐标为（0,0）.现在求给出的点集组成的图形
的面积和重心横纵坐标的和；
输入描述
第一行有一个整数0<n<11,表示有n组数据；
每组数据第一行有一个整数m<10000,表示有这个多边形有m个顶点；
输出描述
输出每个多边形的面积、重心横纵坐标的和，小数点后保留三位；
输入样例
3
3
0 1
0 2
0 3
3
1 1
0 0
0 1
4
1 1
0 0
0 0.5
0 1
输出样例
0.000 0.000
0.500 1.000
0.500 1.000
*/ 
#include<iostream>
#include<cstdio>
#include<cmath>
#include<stdlib.h>
using namespace std;
struct node{
	double x,y;
};
double Area(node p0,node p1,node p2)
{
    double area=0 ;
    area=p0.x*p1.y+p1.x*p2.y+p2.x*p0.y-p1.x*p0.y-p2.x*p1.y-p0.x*p2.y;
    return area/2 ;  // 另外在求解的过程中，不需要考虑点的输入顺序是顺时针还是逆时针，相除后就抵消了。
}
int main()
{
	node p0,p1,p2;
	double sumx,sumy,sumarea,area;
	int T,n;
	scanf("%d",&T);
	while(T--)
	{
		sumx=sumy=sumarea=0;
		scanf("%d",&n);
		scanf("%lf%lf",&p0.x,&p0.y);
		scanf("%lf%lf",&p1.x,&p1.y);
		for(int i=2;i<n;i++)
		{
			scanf("%lf%lf",&p2.x,&p2.y);
			area=Area(p0,p1,p2);
			sumarea+=area;
			sumx+=(p0.x+p1.x+p2.x)*area;
			sumy+=(p0.y+p1.y+p2.y)*area;
			p1=p2;
		}
		if(sumarea==0)
			printf("%.3lf 0.000\n",abs(sumarea));
		else
			printf("%.3lf %.3lf\n",abs(sumarea),sumx/sumarea/3+sumy/sumarea/3);
	}
	return 0;
}
/***********************************************************************************************************************/
/***********************************************************************************************************************/
/***********************************************************************************************************************/
/***********************************************************************************************************************/
/***********************************************************************************************************************/
/***********************************************************************************************************************/
/***********************************************************************************************************************/

