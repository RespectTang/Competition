/*************************************************************************************************************/
正儿八经的巴什博弈
很简单很简单
/*
1471.巴什博弈 (10分) 
C时间限制：3000 毫秒 |  C内存限制：3000 Kb
题目内容：
现实很残酷，kele始终没有逃过被卡塞尔劝退的命运，因为他没有拿到奖学金。
现在等待他的，只有漫无目的的送外卖生活。
送外卖要得有车才行，kele听说街上正在举行一场的摩托车拍卖会，拍卖的物品正
好就是他心目中的那辆哈雷摩托。于是，kele带上他的全部积蓄，冲往拍卖会。
后来发现，整个拍卖会只有kele和这条街的街霸koris。
通过打听，kele知道这场拍卖的规则是这样的：刚开始底价为0，两个人轮流开始加价，
不过每次加价的幅度要在1～N之间，当价格大于或等于摩托车的成本价 M 时，
主办方就把摩托车卖给这次叫价的人。
kele和koris虽然考试不行，但是对拍卖却十分精通，而且他们两个人都十分想得到
辆摩托车。所以他们每次都是选对自己最有利的方式进行加价。
由于kele比koris帅，具体原因不想解释，所以每次都是由kele先开始加价，
为了kele以后的生涯，请问，第一次加价的时候，
kele要出多少才能保证自己买得到这辆摩托车呢？
输入描述
输入一组数据。
包含两个整数M和N(含义见题目描述，0<N，M<1100)
（题目下面的输入输出给的多种情况，只要输入一组就可以了）
输出描述
如果有多个数，在一行里按递增的顺序输出kele第一次可以加的价。两个数据之间
用空格隔开 最后一个数后面有空格，然后换行。
如果只有一个数，输出这个数，直接换行。
如果kele在第一次无论如何出价都无法买到这块土地，就输出"none"，直接换行。
输入样例
N M
3 2
3 5
36 4
输出样例
none
3 4 5
1
*/
#include<iostream>
#include<cstdio>
#include<cmath> 
using namespace std; 
int main()
{
	int n,m;
	cin>>n>>m;
	if(n%(m+1)==0) cout<<"none"<<endl;
	else if(m>=n) 
	{
		for(int i=n;i<=m;i++)
			cout<<i<<' ';
		cout<<endl;
	}
	else cout<<n%(m+1)<<endl;
	return 0;
	
}
/*************************************************************************************************************/
斐波那契博弈
发明这种博弈的大概是鬼才吧
/*
1472.斐波拉契博弈 (10分) 
C时间限制：3000 毫秒 |  C内存限制：3000 Kb
题目内容：
由于kele经常给koris送外卖，koris和kele成为了好朋友。koris最近很想玩游戏，
于是他找到kele和他一起玩，游戏是这样的：
有一堆石子,两个人轮流从其中取走一定的石子,取走最后所有石子的人为赢家,不过得遵循如下规则:
1.第一次取不能取完,至少取1颗。 
2.从第二次开始,每个人取的石子数至少为1,至多为对手刚取的石子数的两倍。
koris事先想知道自己会不会赢，你能帮帮他吗？（每次koris先手）
输入描述
一个整数n(2<=n<2^64);
输出描述
koris会赢输出Yes,否则输出No;然后换行。
*/

#include<iostream>
#include<cstdio>
using namespace std;
#define MAXN 50
int fib[MAXN];
int main()
{
	fib[0]=1;fib[1]=2;
	for(int i=2;i<=50;i++)
		fib[i]=fib[i-1]+fib[i-2];
	int n;
	cin>>n;
	int flag=1;
	for(int i=0;i<=50&&flag;i++)
	{
		if(fib[i]==n) flag=0;
	}
	if(flag)
		printf("Yes\n");
	else
		printf("No\n");
	return 0;
}
/*************************************************************************************************************/
关于博弈的集合
https://blog.csdn.net/MM__1997/article/details/72903794
/*************************************************************************************************************/
/*************************************************************************************************************/
/*************************************************************************************************************/


Nimm's Game
/*************************************************************************************************************/
参考资料：
https://blog.csdn.net/qq_37430374/article/details/79180330
http://www.cnblogs.com/jiangjun/archive/2012/11/01/2749937.html
/*************************************************************************************************************/
/*
653.博弈- 取石头 (10分) 
C时间限制：3000 毫秒 |  C内存限制：3000 Kb
题目内容：
m堆石子,甲乙两人轮流取，每次需先选择1堆，并取任意数目的石子. 最后取完者的获胜.
规定甲先取。
输入描述
可能有多组测试数据。每组的第一行是m, 第二行是m个整数，表示每堆石子的数目。
输出描述
每个测试用例，甲失败则输出“No”。
否则输出"Yes", 并在下面的行输出取法。
按堆号顺序输出各种甲能取胜的首次取法a,b,表示在第a堆石子中取完石子后剩下b个，甲可以获胜。
输入样例
2
45 45
3
3 6 9
5
5 7 8 9 10
输出样例
No
Yes
9 5
Yes
8 1
9 0
10 3
*/ 

#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
int a[1005];

int main()
{
	int m;
	while(cin>>m)
	{
		int flag=0;
		for(int i=0;i<m;i++)
		{
			cin>>a[i];
			flag^=a[i];
		}
			
		if(!flag)
			cout<<"No"<<endl;//如果flag为0则无法取胜 
		else
		{
			int pos,min,k=0;
			cout<<"Yes"<<endl;
			sort(a,a+m);//从小到大顺序输出 
			bool temp[1005]={0};
			int x=flag;
			while(x)
			{
				temp[k++]=x%2;//存储异或结果的二进制	
			
				x/=2;
			}
			//按照解题方法中：
			//检查flag的二进制表示中最左边一个1,则挑一个该位为1的物品堆,
			//再将该物品堆与flag异或,即为该堆剩下的石子数 
			for(int i=k-1;i>=0;i--)
			{
				if(temp[i])
				{
					min=pow(2,i);//找到flag的二进制表示中最左边的一个1,大于它即为该位为1 
					break;	
				}	
			}
			int result;
			for(int i=0;i<m;i++)
				if(a[i]>=min)
				{
					result=a[i]^flag;
					cout<<a[i]<<" "<<result<<endl;
				}
		}
	}
}

/*************************************************************************************************************/
不知道是什么的随便博弈
/*
652.博弈-移动棋子 (10分) 
C时间限制：3000 毫秒 |  C内存限制：3000 Kb
题目内容：
甲乙两人下一种棋。棋盘是一个n个连续的方格子，棋盘上随机放着m个棋子，一个格子只能放一个棋子。
玩家轮流选择一个棋子移动，移动只能从右向左，至少要移动一个格子，但不能跨越其他的棋子和第一个格子,
最后无法移动格子的玩家失败。甲始终先移动。对任何一种初始局面，你能判断谁能赢？
输入描述
第一行是测试用例的数目c, 下面的行是各测试用例
每个测试用例的第一行是整数m(<=1000),表示有m个棋子,第二行是m个整数，表示每个棋子的方格编号（左到右从1开始编号）
输出描述
每个测试用例中赢的一方。
“甲”或者“乙”或者“不确定”
输入样例
2
3
1 2 3
8
1 5 6 7 9 12 14 17
输出样例
乙
甲
*/

#include<iostream>
using namespace std;

int main()
{
	int T;
	cin>>T;
	while(T--)
	{
		int m;
		cin>>m;
		int a[m];
		for(int i=0;i<m;i++)
			cin>>a[i];
		if(a[0]==1)
		{
			if(m%2==0) cout<<"甲"<<endl;
			else cout<<"乙"<<endl; 
		}
		else
		{
			if(m%2==1) cout<<"甲"<<endl;
			else cout<<"乙"<<endl; 
		}
	}
	
	return 0;	
}
/*************************************************************************************************************/
